<!DOCTYPE html>
<html lang="pt-br">
<head>
<meta charset="UTF-8" />
<title>Paciência (Solitaire) - Klondike</title>
<style>
  * {
    box-sizing: border-box;
  }
  body {
    margin: 0; padding: 20px;
    background: #f8f8f8;
    font-family: Tahoma, Geneva, Verdana;
    user-select: none;
    display: flex;
    justify-content: center;
  }
  #game {
    max-width: 1080px;
    width: 100%;
    display: flex;
    flex-direction: column;
    gap: 20px;
  }
  #top-row {
    display: flex;
    justify-content: space-between;
    margin-bottom: 10px;
  }
  .pile-group {
    display: flex;
    gap: 12px;
  }
  #stock, #waste, .foundation {
    width: 100px;
    height: 140px;
    background: #004080;
    border-radius: 8px;
    padding: 5px;
    box-shadow: 0 0 10px rgba(0,0,0,0.3);
    position: relative;
  }
  #stock .card.back, #waste .card {
    position: absolute;
    width: 90px;
    height: 130px;
    top: 5px; left: 5px;
  }
  .foundation {
    background: #003060;
  }
  #tableau {
    display: flex;
    gap: 12px;
  }
  .tableau-col {
    position: relative;
    width: 100px;
    min-height: 400px;
  }
  .tableau-col .card {
    width: 90px;
    height: 130px;
    border-radius: 8px;
    box-shadow: 0 2px 7px rgba(0,0,0,0.5);
    background-color: white;
    position: absolute;
    left: 5px;
    cursor: pointer;
    font-weight: 600;
    font-size: 26px;
    padding: 8px 10px 5px 10px;
    color: black;
    text-align: left;
    user-select: none;
    transition: box-shadow 0.2s ease;
  }
  .card.red {
    color: #b22222;
  }
  .card.back {
    background: linear-gradient(45deg, #555, #999);
    cursor: pointer;
    color: transparent;
  }
  .card .bottom-right {
    position: absolute;
    bottom: 5px;
    right: 8px;
    font-size: 24px;
    pointer-events: none;
  }
  .card.dragging {
    opacity: 0.7;
    box-shadow: 0 0 15px 5px rgba(255,255,255,0.7);
    z-index: 1000;
  }
</style>
</head>

<body>
   <div style="text-align:end;" color="black">
     <p><a href="../jogos.html">Retornar a Jogos</a></p> 
   </div>

<div id="game">
  <div id="top-row" class="pile-group">
    <div id="stock" title="Monte (Clique para virar carta)"></div>
    <div id="waste" title="Descarte"></div>
    <div class="foundation" data-suit="♥" title="Fundação Copas"></div>
    <div class="foundation" data-suit="♦" title="Fundação Ouros"></div>
    <div class="foundation" data-suit="♣" title="Fundação Paus"></div>
    <div class="foundation" data-suit="♠" title="Fundação Espadas"></div>
  </div>

  <div id="tableau"></div>
</div>

<script>
(() => {
  const suits = ['♥','♦','♣','♠'];
  const values = ['A','2','3','4','5','6','7','8','9','10','J','Q','K'];
  let deck = [];
  let stock = [];
  let waste = [];
  let foundations = { '♥': [], '♦': [], '♣': [], '♠': [] };
  let tableau = [[],[],[],[],[],[],[]];

  const stockElem = document.getElementById('stock');
  const wasteElem = document.getElementById('waste');
  const foundationElems = [...document.querySelectorAll('.foundation')];
  const tableauElem = document.getElementById('tableau');

  // Create deck
  function createDeck() {
    deck = [];
    for (let s of suits) {
      for (let v of values) {
        deck.push({ suit: s, value: v, faceUp: false, color: (s==='♥' || s==='♦') ? 'red' : 'black' });
      }
    }
  }
  // Shuffle
  function shuffle(array) {
    for(let i=array.length-1; i>0; i--){
      const j = Math.floor(Math.random()*(i+1));
      [array[i],array[j]]=[array[j],array[i]];
    }
  }
  // Deal cards to tableau and stock
  function deal() {
    stock = [];
    waste = [];
    foundations = { '♥': [], '♦': [], '♣': [], '♠': [] };
    tableau = [[],[],[],[],[],[],[]];

    let index = 0;
    for(let col=0; col<7; col++){
      for(let row=0; row<=col; row++){
        let card = deck[index++];
        card.faceUp = (row === col);
        tableau[col].push(card);
      }
    }
    while(index < deck.length){
      deck[index].faceUp = false;
      stock.push(deck[index++]);
    }
  }
  // Create card element
  function createCardElement(card) {
    const div = document.createElement('div');
    div.classList.add('card');
    if(!card.faceUp) {
      div.classList.add('back');
      div.textContent = '';
    } else {
      div.textContent = card.value + card.suit;
      div.classList.add(card.color);
      const br = document.createElement('div');
      br.className = 'bottom-right';
      br.textContent = card.suit;
      div.appendChild(br);
    }
    return div;
  }
  // Render function
  function render() {
    // Clear all
    stockElem.innerHTML = '';
    wasteElem.innerHTML = '';
    foundationElems.forEach(f => f.innerHTML = '');
    tableauElem.innerHTML = '';

    // Stock (Monte)
    if(stock.length){
      const backCard = createCardElement({faceUp:false});
      backCard.classList.add('back');
      backCard.style.position = 'relative';
      backCard.style.top = '5px';
      backCard.style.left = '5px';
      stockElem.appendChild(backCard);
    }

    // Waste (Descarte)
    if(waste.length){
      const topCard = waste[waste.length-1];
      const topEl = createCardElement(topCard);
      topEl.style.position = 'relative';
      wasteElem.appendChild(topEl);
    }

    // Foundation piles
    for(let s of suits){
      const fElem = foundationElems.find(f => f.dataset.suit === s);
      const pile = foundations[s];
      if(pile.length){
        const topCard = pile[pile.length-1];
        fElem.appendChild(createCardElement(topCard));
      }
    }

    // Tableau
    for(let col=0; col<7; col++){
      const colDiv = document.createElement('div');
      colDiv.className = 'tableau-col';
      colDiv.style.position = 'relative';
      colDiv.style.height = '400px';

      tableau[col].forEach((card, idx) => {
        const cardEl = createCardElement(card);
        cardEl.style.position = 'absolute';
        cardEl.style.top = (idx * 25) + 'px';
        cardEl.style.left = '5px';
        cardEl.dataset.col = col;
        cardEl.dataset.idx = idx;
        if(card.faceUp){
          cardEl.style.cursor = 'pointer';
        } else {
          cardEl.style.cursor = 'default';
        }
        colDiv.appendChild(cardEl);
      });

      tableauElem.appendChild(colDiv);
    }

    addEventListeners();
  }

  // Convert card value to number
  function valueToNumber(val){
    if(val === 'A') return 1;
    if(val === 'J') return 11;
    if(val === 'Q') return 12;
    if(val === 'K') return 13;
    return parseInt(val);
  }

  // Check if movingCard can be placed on destCard in tableau
  function canPlaceOnTableau(movingCard, destCard){
    if(!destCard) return movingCard.value === 'K';
    if(!destCard.faceUp) return false;
    if(movingCard.color === destCard.color) return false;
    return valueToNumber(movingCard.value) === valueToNumber(destCard.value) - 1;
  }

  // Check if movingCard can be placed on foundation pile
  function canPlaceOnFoundation(movingCard, foundationPile){
    if(foundationPile.length === 0) return movingCard.value === 'A';
    const topCard = foundationPile[foundationPile.length-1];
    return movingCard.suit === topCard.suit && valueToNumber(movingCard.value) === valueToNumber(topCard.value) + 1;
  }

  // Drag and drop
  let dragData = null;
  let offsetX = 0;
  let offsetY = 0;

  function addEventListeners(){
    document.querySelectorAll('.card').forEach(card => {
      card.onmousedown = null;
      card.onmouseup = null;
      card.onmousemove = null;
      card.ondragstart = e => e.preventDefault();
    });
    stockElem.onclick = () => {
      if(stock.length === 0){
        stock = waste.reverse().map(c => ({...c, faceUp:false}));
        waste = [];
        render();
      } else {
        let c = stock.pop();
        c.faceUp = true;
        waste.push(c);
        render();
      }
    };

    wasteElem.querySelectorAll('.card').forEach(cardEl => {
      cardEl.style.position = 'relative';
      cardEl.onmousedown = e => {
        e.preventDefault();
        if(waste.length === 0) return;
        dragData = { cards: [waste[waste.length-1]], source: 'waste' };
        startDrag(e, cardEl);
      };
    });

    tableauElem.querySelectorAll('.tableau-col').forEach((colDiv, colIdx) => {
      const cards = tableau[colIdx];
      colDiv.querySelectorAll('.card').forEach((cardEl, idx) => {
        if(!cards[idx].faceUp) return;
        cardEl.style.position = 'absolute';
        cardEl.onmousedown = e => {
          e.preventDefault();
          dragData = { cards: cards.slice(idx), source: 'tableau', col: colIdx, idx: idx };
          startDrag(e, cardEl);
        };
      });
    });

    foundationElems.forEach(fElem => {
      fElem.ondragover = e => e.preventDefault();
      fElem.ondrop = e => {
        e.preventDefault();
        if(!dragData) return;
        if(dragData.cards.length !== 1) return;
        const card = dragData.cards[0];
        const suit = fElem.dataset.suit;
        if(card.suit !== suit) return;
        if(canPlaceOnFoundation(card, foundations[suit])){
          removeDraggedCards();
          foundations[suit].push(card);
          flipLastCard();
          render();
        }
        dragData = null;
      };
    });

    tableauElem.querySelectorAll('.tableau-col').forEach((colDiv, colIdx) => {
      colDiv.ondragover = e => e.preventDefault();
      colDiv.ondrop = e => {
        e.preventDefault();
        if(!dragData) return;
        const destPile = tableau[colIdx];
        const destCard = destPile.length ? destPile[destPile.length - 1] : null;
        if(canPlaceOnTableau(dragData.cards[0], destCard)){
          removeDraggedCards();
          tableau[colIdx] = destPile.concat(dragData.cards);
          flipLastCard();
          render();
        }
        dragData = null;
      };
    });
  }

  function startDrag(e, cardEl){
    e.preventDefault();
    const rect = cardEl.getBoundingClientRect();
    offsetX = e.clientX - rect.left;
    offsetY = e.clientY - rect.top;

    document.body.style.userSelect = 'none';

    cardEl.classList.add('dragging');
    const draggedCards = dragData.cards.map((c,i) => {
      const clone = createCardElement(c);
      clone.style.position = 'fixed';
      clone.style.left = `${e.clientX - offsetX}px`;
      clone.style.top = `${e.clientY - offsetY + i*30}px`;
      clone.style.zIndex = 1000 + i;
      document.body.appendChild(clone);
      return clone;
    });

    function onMouseMove(ev) {
      ev.preventDefault();
      draggedCards.forEach((clone, i) => {
        clone.style.left = `${ev.clientX - offsetX}px`;
        clone.style.top = `${ev.clientY - offsetY + i*30}px`;
      });
    }
    function onMouseUp(ev) {
      ev.preventDefault();
      draggedCards.forEach(clone => clone.remove());
      cardEl.classList.remove('dragging');
      document.removeEventListener('mousemove', onMouseMove);
      document.removeEventListener('mouseup', onMouseUp);

      // Detect drop target
      const elem = document.elementFromPoint(ev.clientX, ev.clientY);
      if(!elem) {
        dragData = null;
        render();
        return;
      }

      // Foundation drop
      let foundationDrop = foundationElems.find(f => f.contains(elem) || f === elem);
      if(foundationDrop){
        foundationDrop.dispatchEvent(new DragEvent('drop', {bubbles:true, cancelable:true}));
        dragData = null;
        return;
      }
      // Tableau drop
      let tableauDrop = null;
      tableauElem.querySelectorAll('.tableau-col').forEach((colDiv) => {
        if(colDiv.contains(elem) || colDiv === elem) {
          tableauDrop = colDiv;
        }
      });
      if(tableauDrop){
        tableauDrop.dispatchEvent(new DragEvent('drop', {bubbles:true, cancelable:true}));
        dragData = null;
        return;
      }
      dragData = null;
      render();
    }
    document.addEventListener('mousemove', onMouseMove);
    document.addEventListener('mouseup', onMouseUp);
  }

  // Remove cards from source piles
  function removeDraggedCards(){
    if(dragData.source === 'waste'){
      waste.pop();
    } else if(dragData.source === 'tableau'){
      tableau[dragData.col].splice(dragData.idx);
    }
  }
  // Flip last card in tableau piles face up if facedown
  function flipLastCard(){
    tableau.forEach(col => {
      if(col.length > 0){
        const lastCard = col[col.length-1];
        if(!lastCard.faceUp){
          lastCard.faceUp = true;
        }
      }
    });
  }

  // Start game
  function init(){
    createDeck();
    shuffle(deck);
    deal();
    render();
  }

  init();
})();
</script>

</body>
</html>
